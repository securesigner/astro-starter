---
/**
 * AnimatedSection — Reusable scroll-triggered animation wrapper
 * ==============================================================
 * Wraps content in an animated container that triggers on viewport entry.
 *
 * Features:
 * - Multiple animation types (fade-up, fade-in, slide-left, slide-right, scale, blur)
 * - Configurable delay for stagger effects
 * - Intersection Observer for scroll-triggered animations
 * - Respects prefers-reduced-motion
 * - Only animates once per element
 * - CSS-only animation (no JS animation frames)
 *
 * Usage:
 *   <AnimatedSection>
 *     <h2>This fades up when scrolled into view</h2>
 *   </AnimatedSection>
 *
 * With options:
 *   <AnimatedSection animation="slide-left" delay={200} threshold={0.3}>
 *     <div>Slides in from left after 200ms delay</div>
 *   </AnimatedSection>
 *
 * For staggered lists:
 *   {items.map((item, i) => (
 *     <AnimatedSection delay={i * 100}>
 *       <Card>{item}</Card>
 *     </AnimatedSection>
 *   ))}
 */

type AnimationType = 'fade-up' | 'fade-in' | 'fade-down' | 'slide-left' | 'slide-right' | 'scale' | 'blur';
type TagName = 'div' | 'section' | 'article' | 'aside' | 'header' | 'footer' | 'main' | 'span';

interface Props extends astroHTML.JSX.HTMLAttributes {
  /** Animation type (default: 'fade-up') */
  animation?: AnimationType;
  /** Delay before animation starts in milliseconds (default: 0) */
  delay?: number;
  /** Animation duration in milliseconds (default: 600) */
  duration?: number;
  /** Intersection threshold 0-1 (default: 0.15) */
  threshold?: number;
  /** Additional CSS classes */
  class?: string;
  /** Whether to animate only once (default: true) */
  once?: boolean;
  /** HTML tag to use (default: 'div') */
  as?: TagName;
}

const {
  animation = 'fade-up',
  delay = 0,
  duration = 600,
  threshold = 0.15,
  class: className = '',
  once = true,
  as: Tag = 'div',
}: Props = Astro.props;

// Generate unique ID for this instance
const id = `animated-section-${Math.random().toString(36).substring(2, 9)}`;
---

<Tag
  id={id}
  class:list={[
    'animated-section',
    `animated-section--${animation}`,
    className,
  ]}
  style={`--animation-delay: ${delay}ms; --animation-duration: ${duration}ms;`}
  data-animation={animation}
  data-threshold={threshold}
  data-once={once}
>
  <slot />
</Tag>

<style>
  /* Base animated section styles */
  .animated-section {
    --animation-delay: 0ms;
    --animation-duration: 600ms;
    transition-property: opacity, transform, filter;
    transition-duration: var(--animation-duration);
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-delay: var(--animation-delay);
    will-change: opacity, transform;
  }

  /* Initial states for each animation type */
  .animated-section--fade-up {
    opacity: 0;
    transform: translateY(2rem);
  }

  .animated-section--fade-down {
    opacity: 0;
    transform: translateY(-2rem);
  }

  .animated-section--fade-in {
    opacity: 0;
  }

  .animated-section--slide-left {
    opacity: 0;
    transform: translateX(3rem);
  }

  .animated-section--slide-right {
    opacity: 0;
    transform: translateX(-3rem);
  }

  .animated-section--scale {
    opacity: 0;
    transform: scale(0.9);
  }

  .animated-section--blur {
    opacity: 0;
    filter: blur(10px);
  }

  /* Visible state — applied when element enters viewport */
  .animated-section.is-visible {
    opacity: 1;
    transform: none;
    filter: none;
  }

  /* Reduced motion preference — show content immediately */
  @media (prefers-reduced-motion: reduce) {
    .animated-section {
      opacity: 1 !important;
      transform: none !important;
      filter: none !important;
      transition: none !important;
    }
  }
</style>

<script>
  /**
   * Initialize scroll-triggered animations using Intersection Observer
   * Runs on page load and Astro page transitions
   */
  function initAnimatedSections() {
    const sections = document.querySelectorAll<HTMLElement>('.animated-section:not(.is-initialized)');

    if (sections.length === 0) return;

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const hasReduceMotionClass =
      document.documentElement.classList.contains('reduce-motion') ||
      document.body.classList.contains('reduce-motion');

    if (prefersReducedMotion || hasReduceMotionClass) {
      // If reduced motion preferred, show all sections immediately
      sections.forEach((section) => {
        section.classList.add('is-visible', 'is-initialized');
      });
      return;
    }

    // Group sections by threshold for efficient observer creation
    const thresholdGroups = new Map<number, HTMLElement[]>();

    sections.forEach((section) => {
      const threshold = parseFloat(section.dataset.threshold || '0.15');
      if (!thresholdGroups.has(threshold)) {
        thresholdGroups.set(threshold, []);
      }
      thresholdGroups.get(threshold)!.push(section);
      section.classList.add('is-initialized');
    });

    // Create an observer for each threshold group
    thresholdGroups.forEach((elements, threshold) => {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const target = entry.target as HTMLElement;
              target.classList.add('is-visible');

              // If animate once, stop observing
              const animateOnce = target.dataset.once !== 'false';
              if (animateOnce) {
                observer.unobserve(target);
              }
            } else {
              // If not animate-once, remove visible class when out of view
              const target = entry.target as HTMLElement;
              const animateOnce = target.dataset.once !== 'false';
              if (!animateOnce) {
                target.classList.remove('is-visible');
              }
            }
          });
        },
        {
          threshold,
          rootMargin: '0px 0px -50px 0px',
        }
      );

      elements.forEach((element) => {
        observer.observe(element);
      });
    });
  }

  // Run on Astro page transitions
  document.addEventListener('astro:page-load', initAnimatedSections);

  // Run immediately for initial page load
  initAnimatedSections();
</script>
